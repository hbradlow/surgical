#include "simulation/simplescene.h"
#include "simulation/softbodies.h"
#include "simulation/config_bullet.h"
#include "simulation/config_viewer.h"
#include <BulletSoftBody/btSoftBodyHelpers.h>
#include <openrave/kinbody.h>
#include "robots/pr2.h"

#include "perception/make_bodies.h"

#include <vtkSmartPointer.h>
#include <vtkPolyDataMapper.h>
#include <vtkActor.h>
#include <vtkParticleReader.h>
#include <vtkRenderWindow.h>
#include <vtkRenderWindowInteractor.h>
#include <vtkRenderer.h>
#include <vtkVertexGlyphFilter.h>
#include <vtkGenericDataObjectReader.h>
#include <vtkStructuredGrid.h>
#include <vtkFloatArray.h>
#include <vtkUnstructuredGrid.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredPoints.h>
#include <vtkSmartPointer.h>
#include <vtkPolyData.h>
#include <vtkMergePoints.h>
#include <vtkCleanPolyData.h>
#include <string>
#include <vector>

#include <vtkCellArray.h>
 
#include <sstream>

#include <Wm5Core.h>
#include <Wm5BSplineCurveFit.h>

#include "simulation/rope.h"

#include <iostream>
#include <pcl/io/pcd_io.h>
#include <pcl/visualization/cloud_viewer.h>
#include <pcl/point_types.h>
#include <pcl/filters/crop_box.h>
#include <pcl/apps/dominant_plane_segmentation.h>

#include "clouds/get_table.h"

#include <cmath>



BulletSoftObject::Ptr makeTowel(const vector<btVector3>& points, btSoftBodyWorldInfo& worldInfo) {
  btVector3 offset(0,0,.01*METERS);
  btSoftBody* psb=btSoftBodyHelpers::CreatePatch(worldInfo,
                                                 points[0]+offset,
                                                 points[1]+offset,
                                                 points[3]+offset,
                                                 points[2]+offset,
                                                 45, 31,
                                                 0/*1+2+4+8*/, true);
  cout << "points[0] " << points[0].x() << " " << points[0].y() << " " << points[0].z() << endl;
  psb->getCollisionShape()->setMargin(.01*METERS);
  btSoftBody::Material* pm=psb->appendMaterial();
  pm->m_kLST            =       5*0.1;
  pm->m_kAST = 5*0.1;
  //    pm->m_flags             -=      btSoftBody::fMaterial::DebugDraw;
  psb->generateBendingConstraints(2, pm);
  psb->setTotalMass(1);

  return BulletSoftObject::Ptr(new BulletSoftObject(psb));
}
// I've only tested this on the PR2 model
class PR2SoftBodyGripperAction : public Action {
    RaveRobotKinematicObject::Manipulator::Ptr manip;
    dReal startVal, endVal;
    vector<int> indices;
    vector<dReal> vals;

    // min/max gripper dof vals
    static const float CLOSED_VAL = 0.03f, OPEN_VAL = 0.54f;

    KinBody::LinkPtr leftFinger, rightFinger;
    const btTransform origLeftFingerInvTrans, origRightFingerInvTrans;

    // the point right where the fingers meet when the gripper is closed
    // (in the robot's initial pose)
    const btVector3 centerPt;

    // vector normal to the direction that the gripper fingers move in the manipulator frame
    // (on the PR2 this points back into the arm)
    const btVector3 closingNormal;

    // points straight down in the PR2 initial position (manipulator frame)
    const btVector3 toolDirection;

    // the target softbody
    btSoftBody *psb;

    btTransform getManipRot() const {
        btTransform trans(manip->getTransform());
        trans.setOrigin(btVector3(0, 0, 0));
        return trans;
    }

    // Returns the direction that the specified finger will move when closing
    // (manipulator frame)
    btVector3 getClosingDirection(bool left) const {
        return (left ? 1 : -1) * toolDirection.cross(closingNormal);
    }

    // Finds some innermost point on the gripper
    btVector3 getInnerPt(bool left) const {
        btTransform trans(manip->robot->getLinkTransform(left ? leftFinger : rightFinger));
        // this assumes that the gripper is symmetric when it is closed
        // we get an innermost point on the gripper by transforming a point
        // on the center of the gripper when it is closed
        const btTransform &origInv = left ? origLeftFingerInvTrans : origRightFingerInvTrans;
        return trans * origInv * centerPt;
        // actually above, we can just cache origInv * centerPt
    }

    // Returns true is pt is on the inner side of the specified finger of the gripper
    bool onInnerSide(const btVector3 &pt, bool left) const {
        // then the innerPt and the closing direction define the plane
        return (getManipRot() * getClosingDirection(left)).dot(pt - getInnerPt(left)) > 0;
    }

    // Fills in the rcontacs array with contact information between psb and pco
    static void getContactPointsWith(btSoftBody *psb, btCollisionObject *pco, btSoftBody::tRContactArray &rcontacts) {
        // custom contact checking adapted from btSoftBody.cpp and btSoftBodyInternals.h
        struct Custom_CollideSDF_RS : btDbvt::ICollide {
            Custom_CollideSDF_RS(btSoftBody::tRContactArray &rcontacts_) : rcontacts(rcontacts_) { }

            void Process(const btDbvtNode* leaf) {
                btSoftBody::Node* node=(btSoftBody::Node*)leaf->data;
                DoNode(*node);
            }

            void DoNode(btSoftBody::Node& n) {
                const btScalar m=n.m_im>0?dynmargin:stamargin;
                btSoftBody::RContact c;
                if (!n.m_battach && psb->checkContact(m_colObj1,n.m_x,m,c.m_cti)) {
                    const btScalar  ima=n.m_im;
                    const btScalar  imb= m_rigidBody? m_rigidBody->getInvMass() : 0.f;
                    const btScalar  ms=ima+imb;
                    if(ms>0) {
                        // there's a lot of extra information we don't need to compute
                        // since we just want to find the contact points
#if 0
                        const btTransform&      wtr=m_rigidBody?m_rigidBody->getWorldTransform() : m_colObj1->getWorldTransform();
                        static const btMatrix3x3        iwiStatic(0,0,0,0,0,0,0,0,0);
                        const btMatrix3x3&      iwi=m_rigidBody?m_rigidBody->getInvInertiaTensorWorld() : iwiStatic;
                        const btVector3         ra=n.m_x-wtr.getOrigin();
                        const btVector3         va=m_rigidBody ? m_rigidBody->getVelocityInLocalPoint(ra)*psb->m_sst.sdt : btVector3(0,0,0);
                        const btVector3         vb=n.m_x-n.m_q; 
                        const btVector3         vr=vb-va;
                        const btScalar          dn=btDot(vr,c.m_cti.m_normal);
                        const btVector3         fv=vr-c.m_cti.m_normal*dn;
                        const btScalar          fc=psb->m_cfg.kDF*m_colObj1->getFriction();
#endif
                        c.m_node        =       &n;
#if 0
                        c.m_c0          =       ImpulseMatrix(psb->m_sst.sdt,ima,imb,iwi,ra);
                        c.m_c1          =       ra;
                        c.m_c2          =       ima*psb->m_sst.sdt;
                        c.m_c3          =       fv.length2()<(btFabs(dn)*fc)?0:1-fc;
                        c.m_c4          =       m_colObj1->isStaticOrKinematicObject()?psb->m_cfg.kKHR:psb->m_cfg.kCHR;
#endif
                        rcontacts.push_back(c);
#if 0
                        if (m_rigidBody)
                                m_rigidBody->activate();
#endif
                    }
                }
            }
            btSoftBody*             psb;
            btCollisionObject*      m_colObj1;
            btRigidBody*    m_rigidBody;
            btScalar                dynmargin;
            btScalar                stamargin;
            btSoftBody::tRContactArray &rcontacts;
        };

        Custom_CollideSDF_RS  docollide(rcontacts);              
        btRigidBody*            prb1=btRigidBody::upcast(pco);
        btTransform     wtr=pco->getWorldTransform();

        const btTransform       ctr=pco->getWorldTransform();
        const btScalar          timemargin=(wtr.getOrigin()-ctr.getOrigin()).length();
        const btScalar          basemargin=psb->getCollisionShape()->getMargin();
        btVector3                       mins;
        btVector3                       maxs;
        ATTRIBUTE_ALIGNED16(btDbvtVolume)               volume;
        pco->getCollisionShape()->getAabb(      pco->getWorldTransform(),
                mins,
                maxs);
        volume=btDbvtVolume::FromMM(mins,maxs);
        volume.Expand(btVector3(basemargin,basemargin,basemargin));             
        docollide.psb           =       psb;
        docollide.m_colObj1 = pco;
        docollide.m_rigidBody = prb1;

        docollide.dynmargin     =       basemargin+timemargin;
        docollide.stamargin     =       basemargin;
        psb->m_ndbvt.collideTV(psb->m_ndbvt.m_root,volume,docollide);
    }

    // adapted from btSoftBody.cpp (btSoftBody::appendAnchor)
    static void appendAnchor(btSoftBody *psb, btSoftBody::Node *node, btRigidBody *body, btScalar influence=1) {
        btSoftBody::Anchor a;
        a.m_node = node;
        a.m_body = body;
        a.m_local = body->getWorldTransform().inverse()*a.m_node->m_x;
        a.m_node->m_battach = 1;
        a.m_influence = influence;
        psb->m_anchors.push_back(a);
    }

    // Checks if psb is touching the inside of the gripper fingers
    // If so, attaches anchors to every contact point
    void attach(bool left) {
        btRigidBody *rigidBody =
            manip->robot->associatedObj(left ? leftFinger : rightFinger)->rigidBody.get();
        btSoftBody::tRContactArray rcontacts;
        getContactPointsWith(psb, rigidBody, rcontacts);
        cout << "got " << rcontacts.size() << " contacts\n";
        for (int i = 0; i < rcontacts.size(); ++i) {
            const btSoftBody::RContact &c = rcontacts[i];
            KinBody::LinkPtr colLink = manip->robot->associatedObj(c.m_cti.m_colObj);
            if (!colLink) continue;
            const btVector3 &contactPt = c.m_node->m_x;
            if (onInnerSide(contactPt, left)) {
                appendAnchor(psb, c.m_node, rigidBody);
                cout << "\tappending anchor\n";
            }
        }
    }

public:
    typedef boost::shared_ptr<PR2SoftBodyGripperAction> Ptr;
    PR2SoftBodyGripperAction(RaveRobotKinematicObject::Manipulator::Ptr manip_,
                  const string &leftFingerName,
                  const string &rightFingerName,
                  float time) :
            Action(time), manip(manip_), vals(1, 0),
            leftFinger(manip->robot->robot->GetLink(leftFingerName)),
            rightFinger(manip->robot->robot->GetLink(rightFingerName)),
            origLeftFingerInvTrans(manip->robot->getLinkTransform(leftFinger).inverse()),
            origRightFingerInvTrans(manip->robot->getLinkTransform(rightFinger).inverse()),
            centerPt(manip->getTransform().getOrigin()),
            indices(manip->manip->GetGripperIndices()),
            closingNormal(manip->manip->GetClosingDirection()[0],
                          manip->manip->GetClosingDirection()[1],
                          manip->manip->GetClosingDirection()[2]),
            toolDirection(util::toBtVector(manip->manip->GetLocalToolDirection())) // don't bother scaling
    {
        if (indices.size() != 1)
            cout << "WARNING: more than one gripper DOF; just choosing first one" << endl;
        setCloseAction();
    }

    void setEndpoints(dReal start, dReal end) { startVal = start; endVal = end; }
    dReal getCurrDOFVal() const {
        vector<dReal> v;
        manip->robot->robot->GetDOFValues(v);
        return v[indices[0]];
    }
    void setOpenAction() { setEndpoints(getCurrDOFVal(), OPEN_VAL); } // 0.54 is the max joint value for the pr2
    void setCloseAction() { setEndpoints(getCurrDOFVal(), CLOSED_VAL); }
    void toggleAction() {
        if (endVal == CLOSED_VAL)
            setOpenAction();
        else if (endVal == OPEN_VAL)
            setCloseAction();
    }

    // Must be called before the action is run!
    void setTarget(btSoftBody *psb_) { psb = psb_; }

    void releaseAllAnchors() {
        psb->m_anchors.clear();
    }

    void reset() {
        Action::reset();
        releaseAllAnchors();
    }

    void step(float dt) {
        if (done()) return;
        stepTime(dt);

        float frac = fracElapsed();
        vals[0] = (1.f - frac)*startVal + frac*endVal;
        manip->robot->setDOFValues(indices, vals);

        if (vals[0] == CLOSED_VAL) {
            attach(true);
            attach(false);
        }
    }
};


struct CustomScene : public Scene {
    PR2SoftBodyGripperAction::Ptr leftAction, rightAction;
    BulletInstance::Ptr bullet2;
    OSGInstance::Ptr osg2;
    Fork::Ptr fork;
    RaveRobotKinematicObject::Ptr origRobot, tmpRobot;
    PR2Manager pr2m;

    CustomScene() : pr2m(*this) { }

    BulletSoftObject::Ptr createCloth(btScalar s, const btVector3 &center);
    BulletSoftObject::Ptr createMesh(string filename, const btVector3 &center,vector<btVector3> *ctrlPts);
    void createFork();
    void swapFork();

    void run();
};

class CustomKeyHandler : public osgGA::GUIEventHandler {
    CustomScene &scene;
public:
    CustomKeyHandler(CustomScene &scene_) : scene(scene_) { }
    bool handle(const osgGA::GUIEventAdapter& ea,osgGA::GUIActionAdapter&);
};

bool CustomKeyHandler::handle(const osgGA::GUIEventAdapter &ea,osgGA::GUIActionAdapter &) {
    switch (ea.getEventType()) {
    case osgGA::GUIEventAdapter::KEYDOWN:
        switch (ea.getKey()) {
        case 'a':
            scene.leftAction->reset();
            scene.leftAction->toggleAction();
            scene.runAction(scene.leftAction, BulletConfig::dt);
            break;
        case 's':
            scene.rightAction->reset();
            scene.rightAction->toggleAction();
            scene.runAction(scene.rightAction, BulletConfig::dt);
            break;
        case 'f':
            scene.createFork();
            break;
        case 'g':
            scene.swapFork();
            break;
        }
        break;
    }
    return false;
}

BulletSoftObject::Ptr CustomScene::createCloth(btScalar s, const btVector3 &center) {
    const int divs = 45;

    btSoftBody *psb = btSoftBodyHelpers::CreatePatch(
        env->bullet->softBodyWorldInfo,
        center + btVector3(-s,-s,0),
        center + btVector3(+s,-s,0),
        center + btVector3(-s,+s,0),
        center + btVector3(+s,+s,0),
        divs, divs,
        0, true);

    psb->m_cfg.piterations = 2;
    psb->m_cfg.collisions = btSoftBody::fCollision::CL_SS
        | btSoftBody::fCollision::CL_RS;
    //    | btSoftBody::fCollision::CL_SELF;
    psb->m_cfg.kDF = 1.0;
    psb->getCollisionShape()->setMargin(0.05);
    btSoftBody::Material *pm = psb->appendMaterial();
    pm->m_kLST = 0.1;
    psb->generateBendingConstraints(2, pm);
    psb->randomizeConstraints();
    psb->setTotalMass(1, true);
    psb->generateClusters(0);

/*    for (int i = 0; i < psb->m_clusters.size(); ++i) {
        psb->m_clusters[i]->m_selfCollisionImpulseFactor = 0.1;
    }*/

    return BulletSoftObject::Ptr(new BulletSoftObject(psb));
}

BulletSoftObject::Ptr CustomScene::createMesh(string filename,const btVector3 &center,vector<btVector3> *ctrlPts) {
	string line = "/home/henrybrad/Desktop/kinfu_tests/test4/mesh.vtk";
	vtkSmartPointer<vtkGenericDataObjectReader> reader = vtkSmartPointer<vtkGenericDataObjectReader>::New();
	reader->SetFileName(line.c_str());
	reader->Update();


	vtkPoints* point_array;
	vtkCellArray* cell_array;
	vtkPointSet* output;

	vtkSmartPointer<vtkCleanPolyData> cleaner =
	vtkSmartPointer<vtkCleanPolyData>::New();
	cleaner->SetInputConnection (reader->GetOutputPort());
	cleaner->Update();
	output = cleaner->GetOutput();

	//read the points and cells from the corresponding file format
	if(reader->IsFilePolyData()){
		point_array = ((vtkPolyData*)cleaner->GetOutput())->GetPoints();
		cell_array = ((vtkPolyData*)cleaner->GetOutput())->GetPolys();
	}
	else{
		point_array = ((vtkPolyData*)cleaner->GetOutput())->GetPoints();
		cell_array = ((vtkPolyData*)cleaner->GetOutput())->GetPolys();
		//point_array = cleaner->GetUnstructuredGridOutput()->GetPoints();
		//cell_array = cleaner->GetUnstructuredGridOutput()->GetCells();
	}
	cout << "Size of set: " << point_array->GetNumberOfPoints() << endl;

	//filter out only the data from the cell array
	float *ft = ((vtkFloatArray*)point_array->GetData())->GetPointer(0);
	int *tt = (int*)((vtkIdTypeArray*)cell_array->GetPointer());
	int *t = (int*)malloc((((cell_array->GetSize()))/4)*3*sizeof(int));
	vector< vector<int> > *cells = new vector< vector<int> >;
	for(int i = 0; i<((cell_array->GetSize()))/4; i++)
	{
		t[i*3+0] = *(tt+i*8+2);
		t[i*3+1] = *(tt+i*8+4);
		t[i*3+2] = *(tt+i*8+6);
	}

	//bring the centroid of the triangle mesh to the origin
	float xave = 0;
	float yave = 0;
	float zave = 0;
	int num = 0;
	for(int i = 0; i<(int)((point_array->GetNumberOfPoints())/1.0); i++)
	{
		xave += *(ft+i*3);
		yave += *(ft+i*3+1);
		zave += *(ft+i*3+2);
		num++;
	}
	xave = xave/num;
	yave = yave/num;
	zave = zave/num;
	for(int i = 0; i<(int)((point_array->GetNumberOfPoints())/1.0); i++)
	{
		*(ft+i*3) -= xave;
		*(ft+i*3+1) -= yave;
		*(ft+i*3+2) -= zave;
	}


/*

	//remove duplicate verticies
	int mVertexCount = (int)((point_array->GetNumberOfPoints())/1.0);
	int dupVertices[mVertexCount];
	int dupVerticesCount = 0;
	int i,j;
	int newIndexes[mVertexCount];
	for(i=0; i < mVertexCount; i++)
	{
	 btVector3 v1 =  btVector3(ft[i*3],ft[i*3+1],ft[i*3+2]);
	 dupVertices[i] = -1;
	 newIndexes[i] = i - dupVerticesCount;
	 for(j=0; j < i; j++)
	 {
		btVector3 v2 =  btVector3(ft[j*3],ft[j*3+1],ft[j*3+2]);;
		if (v1 == v2) {
		   dupVertices[i] = j;
		   dupVerticesCount++;
		   break;
		}
	 }
	}
	printf("dupVerticesCount %d\n", dupVerticesCount);

	int newVertexCount = mVertexCount - dupVerticesCount;
	printf("newVertexCount %d\n", newVertexCount);
	btScalar vertices[newVertexCount * 3];
	for(i=0, j=0; i < mVertexCount; i++)
	{
	 if (dupVertices[i] == -1) {
		btVector3 v =  btVector3(ft[i*3],ft[i*3+1],ft[i*3+2]);;
		vertices[j++] = v.getX();
		vertices[j++] = v.getY();
		vertices[j++] = v.getZ();
	 }
	}

	int mIndexCount  = ((cell_array->GetSize()))*3.0/4;
	int indexes[mIndexCount];
	int idx, idxDup;
	for(i=0; i < mIndexCount; i++)
	{
	 idx = t[i/3][i%3];
	 idxDup = dupVertices[idx];
	 printf("dup %d\n", idxDup);
	 idx = idxDup == -1 ? idx : idxDup;
	 indexes[i] = newIndexes[idx];
	}
	for(i=0;i<mIndexCount; i+=3){
	 vector<int> v;

	 v.push_back(indexes[i]);
	 v.push_back(indexes[i+1]);
	 v.push_back(indexes[i+2]);
	 cells->push_back(v);
	}
	int ntriangles = mIndexCount / 3;

*/
	pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
	pcl::PointCloud<pcl::PointXYZRGB>::Ptr cloudrgb (new pcl::PointCloud<pcl::PointXYZRGB>(cloud->width,cloud->height));
  	if (pcl::io::loadPCDFile<pcl::PointXYZ> ("/home/henrybrad/Desktop/kinfu_tests/test4/cloud.pcd", *cloud) == -1)
  	{
  	  PCL_ERROR ("Couldn't read file test_pcd.pcd \n");
  	}
	cout << "Size of cloud: " << cloud->points.size() << endl;
	for(int i = 0; i<cloud->points.size(); i++){
		pcl::PointXYZRGB p;
		p.x = cloud->points[i].x;
		p.y = cloud->points[i].y;
		p.z = cloud->points[i].z;
		p.r = 255; 
		p.g = 0;
		p.b = 0;
		cloudrgb->points.push_back(p);
	}
	vector<Eigen::Vector3f> corners;
	Eigen::Vector3f normal;
	getTable(cloudrgb,corners,normal,0);

	Eigen::Vector3f v0 = corners[1]-corners[0];
	Eigen::Vector3f v1 = corners[3]-corners[0];
	vector< vector<int> >* cluster_cells = new vector< vector<int> >;
	vector<float>* cluster_vertices = new vector<float>;
	int count = 0;
	for(int i = 0; i<cell_array->GetSize()/4; i++){
		float *point0 = &ft[t[i*3+0]];
		float *point1 = &ft[t[i*3+1]];
		float *point2 = &ft[t[i*3+2]];

		Eigen::Vector3f p0 = Eigen::Vector3f(point0[0],point0[1],point0[2])-corners[0];
		Eigen::Vector3f p1 = Eigen::Vector3f(point1[0],point1[1],point1[2])-corners[0];
		Eigen::Vector3f p2 = Eigen::Vector3f(point2[0],point2[1],point2[2])-corners[0];

		if(abs(v0.dot(p0))<v0.dot(v0) && abs(v1.dot(p0))<v1.dot(v1) && p0.dot(normal)>.2
			&& abs(v0.dot(p1))<v0.dot(v0) && abs(v1.dot(p1))<v1.dot(v1) && p1.dot(normal)>.2
			&& abs(v0.dot(p2))<v0.dot(v0) && abs(v1.dot(p2))<v1.dot(v1) && p2.dot(normal)>.2){
			vector<int> points;

			points.push_back(count);
			points.push_back(count+1);
			points.push_back(count+2);
			count+=3;
			cluster_vertices->push_back(point0[0]);
			cluster_vertices->push_back(point0[1]);
			cluster_vertices->push_back(point0[2]);

			cluster_vertices->push_back(point1[0]);
			cluster_vertices->push_back(point1[1]);
			cluster_vertices->push_back(point1[2]);

			cluster_vertices->push_back(point2[0]);
			cluster_vertices->push_back(point2[1]);
			cluster_vertices->push_back(point2[2]);
			cluster_cells->push_back(points);

		}
	}
	/*
	for(int i = 0; i<point_array->GetNumberOfPoints(); i+=3){
		float *point0 = &ft[i];

		Eigen::Vector3f p0 = Eigen::Vector3f(point0[0],point0[1],point0[2])-corners[0];

		if(abs(v0.dot(p0))<v0.dot(v0) && abs(v1.dot(p0))<v1.dot(v1)){
			cluster_vertices->push_back(point0[0]);
			cluster_vertices->push_back(point0[1]);
			cluster_vertices->push_back(point0[2]);
		}
	}*/

	//make the soft body
//	btSoftBody *psb = btSoftBodyHelpers::CreateFromTriMesh(env->bullet->softBodyWorldInfo,vertices, indexes, ntriangles);
	
	cout << "HERE " << endl;
	int* cluster_indexes = new int[cluster_cells->size()*3];
	float* cluster_vertices_array = new float[cluster_vertices->size()];
	cout << "SIZE " << cluster_cells->size() << endl;
	for(int i = 0; i<cluster_cells->size(); i++){
		cluster_indexes[i*3+0] = (*cluster_cells)[i][0];
		cluster_indexes[i*3+1] = (*cluster_cells)[i][1];
		cluster_indexes[i*3+2] = (*cluster_cells)[i][2];
	}
	cout << "Num Vertices " << cluster_vertices->size() << endl;
	for(int i = 0; i<cluster_vertices->size(); i++){
		cluster_vertices_array[i] = (*cluster_vertices)[i];
	}
	cout << "MADE IT HERE" << endl;

	btSoftBody *psb = btSoftBodyHelpers::CreateFromTriMesh(env->bullet->softBodyWorldInfo,cluster_vertices_array, cluster_indexes, cluster_cells->size());
/*	cout << "Before print" << endl;
	for(int i = 0; i<cell_array->GetSize()/4; i++){
		cout << *(ft+t[i*3+0]) << " " << *(ft+t[i*3+1]) << " " << *(ft+t[i*3+2]) << endl;
	}
	cout << "Before psb" << endl;
	btSoftBody *psb = btSoftBodyHelpers::CreateFromTriMesh(env->bullet->softBodyWorldInfo,ft, t,cell_array->GetSize()/4);*/
	cout << "MADE IT PAST BTSOFTBODY" << endl;






	//load tetgen data from files
	const char * ele = "/home/henrybrad/Desktop/tetgen1.4.3/rope_surface.1.ele";
	FILE *fp;
	long len;
	char *ele_buf;
	fp=fopen(ele,"rb");
	fseek(fp,0,SEEK_END); //go to end
	len=ftell(fp); //get position at end (length)
	fseek(fp,0,SEEK_SET); //go to beg.
	ele_buf=(char *)malloc(len); //malloc buffer
	fread(ele_buf,len,1,fp); //read into buffer
	fclose(fp);
	
	const char * face = "/home/henrybrad/Desktop/tetgen1.4.3/rope_surface.1.face";
	char *face_buf;
	fp=fopen(face,"rb");
	fseek(fp,0,SEEK_END); //go to end
	len=ftell(fp); //get position at end (length)
	fseek(fp,0,SEEK_SET); //go to beg.
	face_buf=(char *)malloc(len); //malloc buffer
	fread(face_buf,len,1,fp); //read into buffer
	fclose(fp);
	cout << "Read Files" << endl;

	const char * node = "/home/henrybrad/Desktop/tetgen1.4.3/rope_surface.1.node";
	char *node_buf;
	fp=fopen(node,"rb");
	fseek(fp,0,SEEK_END); //go to end
	len=ftell(fp); //get position at end (length)
	fseek(fp,0,SEEK_SET); //go to beg.
	node_buf=(char *)malloc(len); //malloc buffer
	fread(node_buf,len,1,fp); //read into buffer
	fclose(fp);
	cout << "Read Files" << endl;
	
	//create soft body from tetgen data
	//btSoftBody *psb = btSoftBodyHelpers::CreateFromTetGenData(env->bullet->softBodyWorldInfo,ele_buf,face_buf,node_buf,false,true,true);


	//set the soft body attributes
    psb->m_cfg.piterations = 20;
//	psb->setVolumeMass(1);
    psb->m_cfg.collisions = btSoftBody::fCollision::CL_RS
	| btSoftBody::fCollision::CL_SS;
        //| btSoftBody::fCollision::CL_SELF;
    psb->m_cfg.kDF = .1;
    //psb->m_cfg.kSSHR_CL = 1.;
    //psb->m_cfg.kSRHR_CL = 1.;
    //psb->m_cfg.kSKHR_CL = 1.;
    //psb->getCollisionShape()->setMargin(0.04);
    btSoftBody::Material *pm = psb->appendMaterial();
    pm->m_kLST = .5;
    psb->generateBendingConstraints(2, pm);
//    psb->randomizeConstraints();
	psb->scale(btVector3(15,15,15));
//	psb->translate(btVector3(-52,-51,15));
	psb->translate(btVector3(24,0,24));
    psb->setTotalMass(.001, true);
    psb->generateClusters(1);


	return BulletSoftObject::Ptr(new BulletSoftObject(psb));
}

void CustomScene::createFork() {
    bullet2.reset(new BulletInstance);
    bullet2->setGravity(BulletConfig::gravity);
    osg2.reset(new OSGInstance);
    osg->root->addChild(osg2->root.get());

    fork.reset(new Fork(env, bullet2, osg2));
    registerFork(fork);

    cout << "forked!" << endl;

    origRobot = pr2m.pr2;
    EnvironmentObject::Ptr p = fork->forkOf(pr2m.pr2);
    if (!p) {
        cout << "failed to get forked version of robot!" << endl;
        return;
    }
    tmpRobot = boost::static_pointer_cast<RaveRobotKinematicObject>(p);
    cout << (tmpRobot->getEnvironment() == env.get()) << endl;
    cout << (tmpRobot->getEnvironment() == fork->env.get()) << endl;
}

void CustomScene::swapFork() {
    // swaps the forked robot with the real one
    cout << "swapping!" << endl;
    int leftidx = pr2m.pr2Left->index;
    int rightidx = pr2m.pr2Right->index;
    origRobot.swap(tmpRobot);
    pr2m.pr2 = origRobot;
    pr2m.pr2Left = pr2m.pr2->getManipByIndex(leftidx);
    pr2m.pr2Right = pr2m.pr2->getManipByIndex(rightidx);

/*    vector<int> indices; vector<dReal> vals;
    for (int i = 0; i < tmpRobot->robot->GetDOF(); ++i) {
        indices.push_back(i);
        vals.push_back(0);
    }
    tmpRobot->setDOFValues(indices, vals);*/
}

void CustomScene::run() {
    viewer.addEventHandler(new CustomKeyHandler(*this));

    const float dt = BulletConfig::dt;
    const float table_height = .5;
    const float table_thickness = .05;
    BoxObject::Ptr table(
        new BoxObject(0, GeneralConfig::scale * btVector3(.75,.75,table_thickness/2),
            btTransform(btQuaternion(0, 0, 0, 1), GeneralConfig::scale * btVector3(1.2, 0, table_height-table_thickness/2))));
    table->rigidBody->setFriction(10);

	vector<btVector3> ctrlPts;
//    BulletSoftObject::Ptr cloth(
//            createCloth(GeneralConfig::scale * 0.25, GeneralConfig::scale * btVector3(0.9, 0, table_height+0.01)));
	BulletSoftObject::Ptr cloth(createMesh("test",GeneralConfig::scale * btVector3(0.9, 0, table_height+0.01),&ctrlPts));
//cout << "Made it out of createMesh" << endl;
	//btRigidBody cloth(createMesh("test",GeneralConfig::scale * btVector3(0.9, 0, table_height+0.01)));
cout << "Made it out of createMesh" << endl;
    btSoftBody * const psb = cloth->softBody.get();
    pr2m.pr2->ignoreCollisionWith(psb);

	boost::shared_ptr<CapsuleRope> ropePtr(new CapsuleRope(ctrlPts,.03));

//	for(int i = 0; i<200; i++){
//		btVector3 v = ctrlPts[i];
  //  		SphereObject::Ptr sphere(new SphereObject(1, 0.003 * GeneralConfig::scale,
    //    	        btTransform(btQuaternion(0,0,0, 1), v)));
//    		env->add(sphere);
//	}

    env->add(table);
//	env->add(ropePtr);
	
    env->add(cloth);

    leftAction.reset(new PR2SoftBodyGripperAction(pr2m.pr2Left, "l_gripper_l_finger_tip_link", "l_gripper_r_finger_tip_link", 1));
    leftAction->setTarget(psb);
    rightAction.reset(new PR2SoftBodyGripperAction(pr2m.pr2Right, "r_gripper_l_finger_tip_link", "r_gripper_r_finger_tip_link", 1));
   rightAction->setTarget(psb);

    //setSyncTime(true);
    startViewer();
    stepFor(dt, 3);

   
    leftAction->setOpenAction();
    runAction(leftAction, dt);

    rightAction->setOpenAction();
    runAction(rightAction, dt);
    

    startFixedTimestepLoop(dt);
}

int main(int argc, char *argv[]) {
    GeneralConfig::scale = 20.;
    ViewerConfig::cameraHomePosition = btVector3(100, 0, 100);
    BulletConfig::dt = 0.01;
    BulletConfig::internalTimeStep = 0.01;
    BulletConfig::maxSubSteps = 0;

//	SceneConfig::enableIK = false;

    Parser parser;

    parser.addGroup(GeneralConfig());
    parser.addGroup(BulletConfig());
    parser.addGroup(SceneConfig());
    parser.read(argc, argv);


    CustomScene().run();
    return 0;
}
